<!DOCTYPE html>
<html>
  <head lang="en">
    <meta charset="UTF-8">
    <title>Scala Presentation</title>
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/default.css">
    <!-- link rel="stylesheet" href="css/highlight/default.css" -->
    <link rel="stylesheet" href="css/highlight/dark.css">
    <style type="text/css">
      p { text-align: left; }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <p>La Scala</p>
          <img src="images/Teatro-La-Scala-Outside.jpg">
        </section>

        <section>
          <p>La Scala!</p>
          <img src="images/Teatro-La-Scala-Inside.jpg"/>
        </section>

        <section>
          <p>NOT that Scala. This Scala:</p>
          <pre>
            <code>
package org.example.fun

class Sample {
  def emitHello: String = "Hello World!"
}
            </code>
          </pre>
        </section>

        <section>
          <p>or this Scala:</p>
          <pre>
            <code>
package org.example.fun

class Sample(val message: String) {
  def emitMessage: String = message
}
            </code>
          </pre>
        </section>

        <section>
          <p>or this Scala which tests the other Scala</p>
          <pre>
            <code>
package org.example.fun

import org.junit.runner.RunWith
import org.scalatest.FunSuite
import org.scalatest.junit.JUnitRunner

@RunWith(classOf[JUnitRunner])
class SampleTestSuite extends FunSuite {

  test("test this sample") {
    val input: String = "Hello World!"
    val messageGenerator: Sample = new Sample(input)
    assert(messageGenerator.emitMessage === input)
  }
}
            </code>
          </pre>
        </section>

        <section>
          <p>This discussion attempts to do the following:</p>
          <ul>
            <li>briefly discuss the need for the Next Big Language</li>
            <li>determine the suitability of Scala as the Next Big Language</li>
          </ul>
        </section>

        <section>
          <p>Principle: Testing is NOT enough to demonstrate correctness.</p>
          <p>"Testing can show the presence of errors but not their absence" - Edsger W. Dijkstra</p>
          <br/>
          <p>Principle: Concurrency is difficult to implement and its correctness is very difficult to demonstrate.</p>
        </section>

        <!-- section>
          <p>Some believe that we need to build better languages and tools in order to build defect free software of
             great complexity.</p>
          <p>Others believe that we need to build better languages and tools in order to easily increase concurrency
             within software of great complexity.</p>
        </section -->

        <section>
          <p>"The special characteristics and advantages of functional programming are often summed up more or less as
              follows. Functional programs contain no assignment statements, so variables, once given a value, never
              change. More generally, functional programs contain no side-effects at all. A function call can have no
              effect other than to compute its result. This eliminates a major source of bugs, and also makes the order
              of execution irrelevant — since no side- effect can change an expression’s value, it can be evaluated at
              any time. This relieves the programmer of the burden of prescribing the flow of control. Since expressions
              can be evaluated at any time, one can freely replace variables by their values and vice versa — that is,
              programs are “referentially transparent”. This freedom helps make functional programs more tractable
              mathematically than their conventional counterparts." John Hughes Functional Programming Matters</p>
        </section>

        <section>
          <p>One reason that the mainstream software community took an interest in Functional programming was due to its
             desire to enhance concurrency. With referential transparency present, optimizing compilers and
             runtimes should be be able to reorder and parallelize function execution much more easily.</p>
          <p>Additionally, with referential transparency present, compilers should be able to prove the correctness of
             our functions and the compositions of our functions.</p>
        </section>

        <section>
          <p>In order to control side-effects, we should make our variables immutable. Any attempt to modify a variable
             marked as a val will result in a compilation error.</p>
          <pre>
            <code>
val n = scala.math.abs(start)
            </code>
          </pre>
        </section>

        <section>
          <p>As mentioned earlier, Scala allows us to create mutable variables, but we should create mutable variables
             only when it is absolutely necessary (and even then, we should not do it). We create mutable variables
             by marking them with the var keyword.</p>
          <pre>
            <code>
var n = scala.math.abs(start)
            </code>
          </pre>
        </section>

        <section>
          <p>Like Java and Go, Scala classes and objects are organized by packages.</p>
          <pre>
            <code>
package com.scala.presentation

class L2 {
...
}
            </code>
          </pre>
          <p>Packages provide logical organization. This allows me to do two things.</p>
          <p>First, packages allow me to place like things together and this calms my disdain for chaos.</p>
          <p>Second, packages allow me to navigate more easily through new codebases.</p>
        </section>

        <section>
          <p>A note on packages in Scala</p>
          <p>The ease of browsing a new codebase depends upon the agreement between packages and directory structure.
             This property does not always hold. Unfortunately, this agreement does not hold for Scala. Therefore,
             developers must make an effort to enforce this alignment.</p>
        </section>

        <section>
          <p>Static members have been removed in Scala</p>
          <p>No static data members</p>
          <p>No static methods</p>
          <p>In place of static data members and static methods, Scala offers the object. Each object is a singleton
             and, therefore, only one instance of it exists at runtime. No special ceremony is required to create an
             object other than to replace the keyword class with the keyword object.</p>
          <pre>
            <code>
package com.scala.presentation

object Application {
  def main(arguments: Array[String]) {
    for (argument <- arguments)
      println("argument: " + argument)
    }
}
            </code>
          </pre>
        </section>

        <section>
          <p>Question: Did everyone notice the for loop?</p>
          <pre>
            <code>
val clothing = List("socks", "pants", "shoes")

for (element <- clothing) {
...
}
            </code>
          </pre>
          <p>This pattern of iteration had already appeared widely in both Java and C#.</p>
        </section>

        <section>
          <p>Because Scala is functional, it provides the function construct. Although Scala does not enforce this,
             the Scala community encourages the development of functions which are free of side-effects.</p>
          <p>This is an example of a function.</p>
          <pre>
            <code>
package com.scala.presentation

object Max {
  def max(x: Int, y: Int): Int =
    if (x >= y)
      x
    else
      y
}
            </code>
          </pre>
        </section>

        <section>
          <p>This is a more complicated example of a function.</p>
          <pre>
            <code>
package com.scala.presentation

object P01 {
  def last[T](list: List[T]): T =
    list match {
      case Nil => throw new NoSuchElementException
      case x :: Nil => x
      case x :: xs => last(xs)
    }
}
            </code>
          </pre>
        </section>

        <section>
          <p>Additionally, Scala allows us to define functions within functions.</p>
          <pre>
            <code>
package com.scala.presentation

object P04 {
  def length[T](list: List[T]): Int = {
    def lengthAssistant(list: List[T], accumulator: Int): Int =
      list match {
        case Nil => accumulator
        case x :: xs => lengthAssistant(xs, (accumulator + 1))
      }

    lengthAssistant(list, 0)
  }
}
            </code>
          </pre>
        </section>

        <section>
          <p>Question: What is all this accumulator business we've seen in the last few slides?</p>
          <p>Answer: The use of accumulators allows the developer to receive all of the efficiency of iteration with the
             elegance of recursion. This technique is called tail recursion.</p>
          <pre>
            <code>
package com.scala.presentation

object Reverse {

  def reverse[T](list: List[T]): List[T] = {
    def reverseAssistant(list: List[T], accumulator: List[T]): List[T] =
      list match {
        case Nil => accumulator
        case x :: xs => reverseAssistant(xs, x :: accumulator)
      }

      reverseAssistant(list, Nil)
  }
}
            </code>
          </pre>
        </section>

        <section>
          <p>Scala is organized by inheritance as follows:</p>
          <img src="images/Scala-Type-Hierarchy.png"/>
        </section>

        <section>
          <p>Question: Why Scala?</p>
          <p>Answer: Scala combines the paradigms of Object-Orientation and Functional programming. While Scala does not
             prevent one from using mutable variables and, therefore, introducing side-effects, it does encourage one to
             use immutable variables. Scala can be seen as a transitional technology. Scala resides within the world of
             Object-Orientation, but it offers developers the opportunity to use Functional techniques.</p>
        </section>

        <section>
          <p>Advantages of Scala</p>
          <p>"It Keeps Idiots Out. The biggest advantage of Scala, at least so far, is that it keeps a certain type of
              coder out of the codebase."</p>
          <a href="http://www.nomachetejuggling.com/2011/12/15/scala-first-impressions/">
            http://www.nomachetejuggling.com/2011/12/15/scala-first-impressions/
          </a>
          <p>Code damage is a serious problem.</p>
          <img src="images/codedamage.png"/>
        </section>

        <section>
          <p>Disadvantages of Scala</p>
          <p>It Keeps Idiots Out</p>
          <p>I speculate that the Next Big Language must allow junior developers to participate without allowing them to
             damage the codebase.</p>
          <p>Question: Is it possible for a language to be both restrictive and fun?</p>
        </section>

        <section>
          <p>At this point, several concessions must be made.</p>
          <p>First, Functional programming is not necessarily the next big thing.</p>
          <p>Second, even if Functional programming emerges as the next big thing, we cannot be sure that Scala will be
             the vehicle of choice for Functional development.</p>
          <p>On the other hand, Functional programming merits serious consideration. Should we choose to explore
             Functional programming, we will need some vehicle to explore its terrain. I believe that Scala is a
             fantastic candidate for this exploration.</p>
        </section>

        <section>
          <p>Looking forward by looking back</p>
          <p>Question: What were the last few NBLs?</p>
        </section>

        <section>
          <p>Reflection</p>
          <p>Question: Is it possible for a language to be both restrictive and fun?</p>
          <p>Question: Is it even necessary for the NBL to be restrictive?</p>
        </section>
      </div>
    </div>

    <script type="application/javascript" src="lib/js/head.min.js"></script>
    <script type="application/javascript" src="lib/js/highlight.pack.js"></script>
    <script type="application/javascript" src="js/reveal.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script type="application/javascript">
      Reveal.initialize({
          controls: true,
          keyboard: true,
          center: false,
          theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
          transition: Reveal.getQueryHash().transition || 'default', // none/fade/slide/convex/concave/zoom

          dependencies: [
              {
                  src: 'plugin/notes/notes.js',
                  async: true
              },
              {
                  src: 'plugin/markdown/showdown.js',
                  async: true
              },
              {
                  src: 'plugin/markdown/markdown.js',
                  async: true
              },
              {
                  src: 'plugin/zoom-js/zoom.js',
                  async: true
              },
              {
                  src: 'plugin/highlight/highlight.js',
                  async: true,
                  callback: function() { hljs.initHighlightingOnLoad(); }
              }
      ]
      });
    </script>
  </body>
</html>
